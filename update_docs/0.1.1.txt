ver. 0.1.1

private키를 chrome.local에 저장하는 형태가 아닌
휘발하는 형태로 만듦.

to me: 
입력값을 받거나 save 버튼을 누르거나 send transaction을 눌렀을 때 privatekey 변수를 받는다면 
실제로 timeset안에 스크립트가 돌아가기 때문에 그때는 이미 privatekey가 날아가버림.

그래서 스크립트 안에, privatekey에 입력된 값을 받는다. <- Stack / Heap 이건 좀 공부해야할 듯
이렇게 하면 로컬 storage안에 안남고 스크립트 돌리고 나면 휘발하는 형태로 privatekey를 입력할 수있다.

이러면 보안 문제가 상당히 많이 해소된 느낌
⬜⬜⬜⬜⬜⬜⬛⬛⬛⬛⬛⬛⬛⬜⬜⬜⬜⬜⬜
⬜⬜⬜⬜⬛⬛🟨🟨🟨🟨🟨🟨🟨⬛⬛⬜⬜⬜⬜
⬜⬜⬜⬛🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨⬛⬜⬜⬜
⬜⬜⬛🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨⬛⬜⬜
⬜⬜⬛🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨⬛⬜⬜
⬜⬛🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨⬛⬜
⬜⬛🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨⬛⬜
⬛⬛⬛⬛⬛⬛⬛⬛⬛⬛⬛⬛⬛⬛⬛⬛⬛⬛⬛
⬛🟨⬛⬛⬛⬛⬜⬜⬛⬛⬛⬛⬛⬛⬜⬜⬛🟨⬛
⬛🟨⬛⬛⬛⬛⬜⬛⬛🟨⬛⬛⬛⬛⬜⬛⬛🟨⬛
⬛🟨🟨⬛⬛⬛⬛⬛🟨🟨🟨⬛⬛⬛⬛⬛🟨🟨⬛
⬛🟨🟨🟨⬛⬛⬛🟨🟨🟨🟨🟨⬛⬛⬛🟨🟨🟨⬛
⬜⬛🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨⬛⬜
⬜⬛🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨⬛⬜
⬜⬜⬛🟨🟨🟨⬛🟨🟨🟨🟨🟨⬛🟨🟨🟨⬛⬜⬜
⬜⬜⬛🟨🟨🟨🟨⬛⬛⬛⬛⬛🟨🟨🟨🟨⬛⬜⬜
⬜⬜⬜⬛🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨⬛⬜⬜⬜
⬜⬜⬜⬜⬛⬛🟨🟨🟨🟨🟨🟨🟨⬛⬛⬜⬜⬜⬜
⬜⬜⬜⬜⬜⬜⬛⬛⬛⬛⬛⬛⬛⬜⬜⬜⬜⬜⬜

**
gpt : 
야 그럼 뭔가 클릭했을 때랑,
실제로 트랜잭션이 스케쥴 되어서 보낼 때랑 시간 딜레이가 있어서 그 사이에 날아가는게 아닐까?

ChatGPT의 말:
ChatGPT
맞습니다! 말씀하신 것처럼 시간 딜레이가 문제일 수 있습니다. 특히 트랜잭션을 스케줄링할 때, 
트랜잭션을 보내기 위한 대기 시간이 길어지면 그 사이에 privateKey가 휘발성으로 처리되어 없어질 가능성이 큽니다. 즉, 트랜잭션이 실행될 때 필요한 privateKey가 더 이상 존재하지 않는 상황이 발생할 수 있습니다.
이 문제를 해결하기 위해 몇 가지 방법을 고려할 수 있습니다:

해결 방법:
PrivateKey를 트랜잭션 실행 직전에 저장하고 사용:
트랜잭션을 보내기 바로 직전에 privateKey를 다시 가져오거나 입력받을 수 있습니다. 이를 위해 setTimeout 안에서 직접 privateKey를 가져와 사용하는 방식으로 코드를 변경할 수 있습니다.
PrivateKey를 안전하게 유지:
privateKey를 트랜잭션을 보낼 때만 안전하게 메모리에 보관하고, 실행될 때까지 유지되도록 할 수 있습니다. 이 경우, 메모리에서만 유지되는 방식으로 코드를 작성합니다.

gpt :
메모리에만 보관한다는게 뭘까. 컴퓨터의 메모리 구조와 내가 돌리는 js 언어의 특성 등을 정확하게 나한테 설명해줘 . 
쉬운 비유 말고 어려운 용어를 써도돼. 


ChatGPT의 말:
ChatGPT
JavaScript는 고수준 언어로서, 
일반적으로 런타임 환경에서 실행됩니다. 
이는 브라우저나 서버 측 엔진(Node.js 등)을 의미하며, 
이러한 환경은 저수준 메모리 관리(예: 수동으로 메모리를 할당하거나 해제하는 작업)를 추상화해 줍니다.

메모리 구조
컴퓨터 메모리 구조는 주로 **스택(stack)**과 **힙(heap)**으로 나뉩니다.

스택:
고정 크기의 데이터를 저장하는 메모리 영역입니다.
JavaScript에서는 기본 데이터 타입(Primitive Types)인 
number, string, boolean, null, undefined 등이 스택에 저장됩니다.
이 메모리는 LIFO(Last In, First Out) 방식으로 작동하며, 
함수가 호출될 때마다 **호출 스택(Call Stack)**에 그 함수의 컨텍스트가 쌓이고, 
함수가 종료되면 그 컨텍스트가 사라집니다. 함수 호출과 리턴이 빠르며, 메모리 할당과 해제가 명확합니다.

힙:
가변 크기의 데이터를 저장하는 메모리 영역입니다.
객체(Object), 배열(Array), 함수(Function) 등 복합 데이터 타입은 모두 힙에 저장됩니다.
힙은 스택과 달리 LIFO 규칙을 따르지 않으며, 복잡한 참조 관계가 가능합니다. JavaScript의 
**가비지 컬렉터(Garbage Collector)**가 주기적으로 불필요한 메모리를 해제하면서 메모리를 관리합니다.
JavaScript의 메모리 관리
JavaScript는 자동 메모리 관리를 통해 개발자가 직접 메모리를 할당하거나 해제하지 않아도 됩니다. 
이 작업은 주로 **가비지 컬렉터(GC)**에 의해 이루어집니다. 가비지 컬렉터는 더 이상 참조되지 않는 
객체를 찾아 메모리에서 해제하는 역할을 합니다.

참조 카운팅(reference counting): 특정 데이터가 더 이상 참조되지 않으면 가비지 컬렉터가 그 데이터를 메모리에서 해제합니다.
표시-스위프(mark-and-sweep): 가비지 컬렉터는 실행 가능한 객체들과 그렇지 않은 객체들을 구별해 사용되지 않는 객체들을 해제합니다.
메모리에만 보관한다는 의미
자바스크립트에서 메모리에만 보관한다는 것은 privateKey와 같은 중요한 정보를 
**영구적으로 저장(storage)**하지 않고, **메모리(heap)**에만 저장해서 트랜잭션을 실행할 때만 사용한다는 의미입니다.

자세히 설명하자면:
privateKey는 JavaScript 코드 내에서만 존재하며, 브라우저의 로컬 스토리지 또는 파일 시스템 같은 영구 저장소에 기록되지 않습니다.
코드 실행 중에만 privateKey가 메모리에서 유지되며, 코드 실행이 끝나거나 페이지가 새로 고침되면 그 값은 사라집니다. 
이는 privateKey가 휘발성 메모리(Volatile Memory)인 **RAM(Random Access Memory)**에만 저장된다는 의미입니다.
이 과정에서 브라우저가 페이지를 닫거나 새로 고침하면, 메모리에서 휘발된 데이터는 가비지 컬렉터에 의해 해제됩니다.

JavaScript 엔진의 메모리 특성
JavaScript는 비동기 프로그래밍을 지원하는 언어로, **이벤트 루프(Event Loop)**를 통해 비동기 작업을 처리합니다. 
여기서 중요한 점은 **클로저(closure)**입니다.

클로저는 외부 함수의 컨텍스트를 유지한 채 내부 함수가 실행될 수 있게 해 줍니다. 예를 들어, 비동기 작업이 실행될 때, 
클로저를 통해 외부의 변수를 참조할 수 있으며, 이 변수가 스택이 아닌 힙에 저장되어 있으므로 
이벤트가 완료되기 전까지 해당 변수는 메모리에 남아있습니다.
하지만 이벤트 루프가 끝나고 클로저 내에서 참조된 변수가 더 이상 필요하지 않으면 가비지 컬렉터가 이를 해제하게 됩니다.
이러한 특성 때문에, setTimeout과 같은 비동기 작업에서 privateKey를 사용하면, 
트랜잭션 실행 시점까지 그 변수를 메모리에서 유지할 수 있습니다.

정리
스택은 함수 호출과 관련된 기본 데이터를 저장하고, 함수가 끝나면 해제됩니다.
힙은 객체와 같은 복합 데이터를 저장하며, 클로저를 통해 이벤트 루프가 끝날 때까지 메모리에 남을 수 있습니다.
JavaScript의 자동 메모리 관리 덕분에, 개발자는 메모리를 수동으로 해제할 필요가 없으며, 필요 시 데이터를 메모리에만 유지할 수 있습니다.


ㄷㄷㄷㄷ; 
이거 엊그제 본 영상. 어려워서 대충 봤는데 다시 봐야겠음. 역시 사람은 닥치면 공부하는듯
https://www.youtube.com/watch?v=v67LloZ1ieI